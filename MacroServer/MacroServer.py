#!/usr/bin/env python

#    "$Name:  $";
#    "$Header:  $";
#=============================================================================
#
# file :        MacroServer.py
#
# description : Python source for the MacroServer and its commands. 
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#                MacroServer are implemented in this file.
#
# project :     TANGO Device Server
#
# $Author$
#
# $Revision$
#
# $Log:  $
#
# copyleft :    European Synchrotron Radiation Facility
#               BP 220, Grenoble 38043
#               FRANCE
#
#=============================================================================
#          This file is generated by POGO
#    (Program Obviously used to Generate tango Object)
#
#         (c) - Software Engineering Group - ESRF
#=============================================================================
#

import sys, os, copy, threading, logging.handlers

import PyTango

import taurus
from taurus.core.util import Logger

from exception import MacroServerException

_main_log = None

__requires__ = {
#     module     minimum  recommended 
    "Python"      : (2,4,0),
    "PyTango"     : (7,1,0),
    "taurus.core" : (2,0,0)
}

def check_requirements():
    
    pyver_ = __requires__['Python']
    pytangover_ = __requires__['PyTango']
    taurusver_ = __requires__['taurus.core']
    
    pyver = sys.version_info[:3]
    
    try:    pytangover = PyTango.__version_info__[:3]
    except: pytangover = tuple(map(int, PyTango.__version__.split('.', 3)))
    
    try:    taurusver = taurus.Release.version_info[:3]
    except: taurusver = tuple(map(int, taurus.Release.version.split('.', 3)))
    
    if pyver < pyver_:
        print "MacroServer requires python %s. Installed version is %s" % (pyver_, pyver)
        sys.exit(-1)

    if pytangover < pytangover_:
        print "MacroServer requires PyTango %s. Installed version is %s" % (pytangover_, pytangover)
        sys.exit(-1)

    if taurusver < taurusver_:
        print "MacroServer requires taurus %s. Installed version is %s" % (taurusver_, taurusver)
        sys.exit(-1)
    
    try:
        taurus.core.util.etree
    except:
        print "Could not find any suitable XML library"
        sys.exit(-1)



def get_main_log():
    global _main_log
    if not _main_log is None:
        return _main_log
    
    # set the log level
    taurus.setLogLevel(taurus.Trace)
    
    _main_log = Logger("Main")
        
    # Two additional log levels: 
    # output of a macro
    Logger.addLevelName(15, "OUTPUT")

    def output(slf, msg, *args, **kw):
        slf.getLogObj().log(Logger.Output, msg, *args, **kw)

    Logger.output = output

    # result of a macro
    Logger.addLevelName(18, "RESULT")
    
    root = Logger.getRootLog()
    
    log_level_map = { '5' : taurus.Trace,
                      '4' : taurus.Debug,
                      '3' : taurus.Info,
                      '2' : taurus.Warning,
                      '1' : taurus.Error }
    
    output_log_level = Logger.Info
    for arg in sys.argv[1:]:
        if arg.startswith('-log'):
            output_log_level = log_level_map.get(arg[-1], output_log_level)
            break

    #Stream handler (output) should be filtered for output or higher messages
    root.handlers[0].setLevel(output_log_level)
    #for h in handlers:
    #    root.removeHandler(h)
    
    # Create a file handler
    app = os.path.split(sys.argv[0])[1]
    app = os.path.splitext(app)[0]
    path = os.path.join("/tmp/tango", app, sys.argv[1])
    filename = os.path.join(path, 'log.txt')
    try:
        if not os.path.exists(path):
            os.makedirs(path, 0777)
        
        fmt = Logger.getLogFormat()
        f_h = logging.handlers.RotatingFileHandler(filename, maxBytes=5E8, backupCount=5)
        f_h.setFormatter(fmt)
        
        # Create a memory handler and set the target to the file handler
        m_h = logging.handlers.MemoryHandler(10, flushLevel=logging.INFO)
        m_h.setTarget(f_h)
        root.addHandler(m_h)
    except Exception, e:
        _main_log.warning("'%s' could not be created. Logs will not be stored" % filename)
        _main_log.debug("reason: %s" % str(e))
    
    return _main_log

if __name__ == "__main__":
    check_requirements()
    get_main_log()

class GenericListAttribute(PyTango.SpectrumAttr):
    pass

#==================================================================
#   MacroServer Class Description:
#
#         A device server that handles execution of macros written by users as plugins.
#
#==================================================================

class MacroServer(PyTango.Device_4Impl, Logger):

#--------- Add you global variables here --------------------------

#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        try:
            db = taurus.Factory().getDatabase()
            self._alias = db.get_alias(name)
            if self._alias.lower() == 'nada':
                self._alias = name
        except:
            self._alias = name
        Logger.__init__(self, self._alias)
        MacroServer.init_device(self)

    def __getManager(self, *args):
        import manager
        return manager.MacroServerManager(*args)
    
#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    def delete_device(self):
        self.__getManager().cleanUp()
        
#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    def init_device(self):
        self.set_state(PyTango.DevState.ON)
        self.set_change_event('State', True, False)
        self.set_change_event('Status', True, False)
        self.set_change_event('TypeList', True, False)
        self.set_change_event('DoorList', True, False)
        self.set_change_event('MacroList', True, False)
        self.set_change_event('MacroLibList', True, False)
        
        dev_class = self.get_device_class()
        self.get_device_properties(dev_class)
        
        self.EnvironmentDb = self._calculate_environment_name(self.EnvironmentDb)

        _macro_dirs = []
        for md in self.MacroPath:
            _macro_dirs.extend(md.split(':'))
        self.MacroPath = _macro_dirs

        # Init MacroServer Manager
        # it is important that the MacroServerManager singleton be called
        # here for the first time. So don't call it in the main or 
        # MacroServerClass
        manager_params = self.PoolNames, self.MacroPath, self.EnvironmentDb, self.MaxParallelMacros
        ms_manager = self.__getManager(*manager_params)
        ms_manager.reInit(*manager_params)
        
        dl = ms_manager.getDoorListObj()
        if not dl.isSubscribed(self.doorsChanged):
            dl.subscribeEvent(self.doorsChanged)
        
        if self.RConsolePort:
            try:
                import rfoo.utils.rconsole
                rfoo.utils.rconsole.spawn_server(port=self.RConsolePort)
            except Exception,e:
                print e

    def _calculate_environment_name(self, name):
        u = PyTango.Util.instance()
        return name % { 'ds_name' : u.get_ds_name() }

#------------------------------------------------------------------
#    Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        pass

#==================================================================
#
#    MacroServer read/write attribute methods
#
#==================================================================
#------------------------------------------------------------------
#    Read Attribute Hardware
#------------------------------------------------------------------
    def read_attr_hardware(self,data):
        pass

#------------------------------------------------------------------
#    Read DoorList attribute
#------------------------------------------------------------------
    def read_DoorList(self, attr):
        #    Add your own code here
        ms_manager = self.__getManager()
        door_list_obj = ms_manager.getDoorListObj()
        attr.set_value(door_list_obj.read())
        
#------------------------------------------------------------------
#    Read MacroList attribute
#------------------------------------------------------------------
    @PyTango.DebugIt()
    def read_MacroList(self, attr):
        self.info_stream("inside read_MacroList")
        #    Add your own code here
        ms_manager = self.__getManager()
        macro_list_obj = ms_manager.getMacroListObj()
        attr.set_value(macro_list_obj.read())

#------------------------------------------------------------------
#    Read MacroLibList attribute
#------------------------------------------------------------------
    def read_MacroLibList(self, attr):
        
        #    Add your own code here
        ms_manager = self.__getManager()
        macro_lib_list_obj = ms_manager.getMacroLibListObj()
        attr.set_value(macro_lib_list_obj.read())
        
#------------------------------------------------------------------
#    Read TypeList attribute
#------------------------------------------------------------------
    def read_TypeList(self, attr):
        
        #    Add your own code here
        
        ms_manager = self.__getManager()
        type_list_obj = ms_manager.getTypeListObj()
        attr.set_value(type_list_obj.read())

#==================================================================
#
#    MacroServer command methods
#
#==================================================================

#------------------------------------------------------------------
#    GetMacroInfo command:
#
#    Description: Returns information about the macro (description, parameters, return (if any), etc)
#                
#    argin:  DevVarStringArray    Macro(s) name(s)
#    argout: DevVarStringArray    Macro description
#------------------------------------------------------------------
    def GetMacroInfo(self, argin):
        """GetMacroInfo(list<string> macro_names):
        
           Returns a list of string representing macro information.
           
           Params:
               - macro_name: a list of strings with the macro(s) name(s)
           Returns:
               - list[0]: macro description (documentation)
                 list[1]: macro hints, if any
                 list[2]: number of parameters = N
                 list[3...3+4*N]: parameter info: name, type, desc, default value
                 list[4+4*N]: number of results = M
                 list[5+4*N...5+4*N+4*M]: result info: name, type, desc, default value
        """        

        #    Add your own code here
        
        return self.__getManager().getMacroInfo(argin)
    
#------------------------------------------------------------------
#    ReloadMacro command:
#
#    Description: Reloads the macro code for the given macro. Attention: this
#    command reloads the entire python module containning the given macro code
#                
#    argin:  DevVarStringArray    Macro(s) name(s)
#    argout: DevVarStringArray    [OK] if successfull or a traceback if there 
#                                 was a error (one string with complete 
#                                 traceback of each error)
#------------------------------------------------------------------
    def ReloadMacro(self, argin):
        """ReloadMacro(list<string> macro_names):
        """
        #    Add your own code here
        try:
            self.__getManager().reloadMacros(argin)
        except MacroServerException, mse:
            PyTango.Except.throw_exception(mse.type, mse.msg, 'ReloadMacro')
        return ['OK']

#------------------------------------------------------------------
#    ReloadMacroLib command:
#
#    Description: Reloads the macro code for the given macro. Attention: this
#    command reloads the entire python module containning the given macro code
#                
#    argin:  DevVarStringArray    Lib(s) name(s)
#    argout: DevVarStringArray    [OK] if successfull or a traceback if there 
#                                 was a error (one string with complete 
#                                 traceback of each error)
#------------------------------------------------------------------
    def ReloadMacroLib(self, argin):
        """ReloadMacroLib(sequence<string> lib_names):
        """
        #    Add your own code here
        try:
            self.__getManager().reloadMacroLibs(argin)
        except MacroServerException, mse:
            PyTango.Except.throw_exception(mse.type, mse.msg, 'ReloadMacroLib')
        return ['OK']
    
    def GetMacroCode(self, argin):
        """GetMacroCode(<module name> [, <macro name>]) -> full filename, code, line_nb
        """
        #    Add your own code here
        ret = self.__getManager().getOrCreateMacroLib(*argin)
        ret = map(str, ret)
        return ret
    
    def SetMacroCode(self, argin):
        self.__getManager().setMacroLib(*argin)
    
    def dyn_attr(self):
        ms_manager = self.__getManager()
        type_list_obj = ms_manager.getTypeListObj()
        type_list_obj.subscribeEvent(self.typesChanged)
        macro_list_obj = ms_manager.getMacroListObj()
        macro_list_obj.subscribeEvent(self.macrosChanged)
        macro_lib_list_obj = ms_manager.getMacroLibListObj()
        macro_lib_list_obj.subscribeEvent(self.macroLibsChanged)
    
    def typesChanged(self, data, type_data):
        all_types, old_types, new_types = type_data
        
        for type_name in old_types:
            if type_name[-1] == '*':
                self.removeTypeAttribute(type_name[:-1])

        for type_name in new_types:
            if type_name[-1] == '*':
                self.addTypeAttribute(type_name[:-1])

        self.push_change_event('TypeList', all_types)
    
    def addTypeAttribute(self, name):
        self.trace("Adding dynamic attribute %s" % name)
        attr_name = "%sList" % name
        attr_data = (name, attr_name)
        attr = GenericListAttribute(attr_name, PyTango.DevString,
                                    PyTango.READ, 2048)
        self.add_attribute(attr, MacroServer.read_GenericList)
        
        self.set_change_event(attr_name, True, False) 
        
        type_obj = self.__getManager().getTypeObj(name)
        type_obj.subscribeEvent(self.genericListChanged, attr_data)
    
    def removeTypeAttribute(self, name):
        pass
    
    def macrosChanged(self, data, macro_data):
        all_macros = macro_data[0]
        self.push_change_event('MacroList', all_macros) 
        
    def macroLibsChanged(self, data, macro_lib_data):
        all_macro_libs = macro_lib_data[0]
        self.push_change_event('MacroLibList', all_macro_libs) 

    def genericListChanged(self, attr_data, data):
        pass

    def doorsChanged(self, attr_data, data):
        pass

    def read_GenericList(self, attr):
        attr_name = attr.get_name()
        type_name = attr_name[:attr_name.index('List')]
        type_obj = self.__getManager().getTypeObj(type_name)
        item_list = type_obj.read()
        attr.set_value(item_list)


#==================================================================
#
#    MacroServerClass class definition
#
#==================================================================
class MacroServerClass(PyTango.DeviceClass, Logger):

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'PoolNames':
            [PyTango.DevVarStringArray,
            "Sardana device pool device names",
            [] ],
        'MacroPath':
            [PyTango.DevVarStringArray,
            "List of directories (absolute or relative path) that contain macro files.",
            [] ],
        'MaxParallelMacros':
            [PyTango.DevLong,
            "Maximum number of macros that can execute concurrently.",
            [10] ],
        'EnvironmentDb':
            [PyTango.DevString,
            "The environment database (usualy a plain file).",
            ["/tmp/tango/%(ds_name)s/macroserver.properties"] ],
        'RConsolePort':
            [PyTango.DevLong,
            "The rconsole port number",
            None ],
        }

    #    Command definitions
    cmd_list = {
        'GetMacroInfo':
            [[PyTango.DevVarStringArray, "Macro(s) name(s)"],
            [PyTango.DevVarStringArray, "Macro(s) description(s)"]],
        'ReloadMacro':
            [[PyTango.DevVarStringArray, "Macro(s) name(s)"],
            [PyTango.DevVarStringArray, "[OK] if successfull or a traceback " \
                "if there was a error (one string with complete traceback of " \
                "each error)"]],
        'ReloadMacroLib':
            [[PyTango.DevVarStringArray, "MacroLib(s) name(s)"],
            [PyTango.DevVarStringArray, "[OK] if successfull or a traceback " \
                "if there was a error (one string with complete traceback of " \
                "each error)" ]],
        'GetMacroCode':
            [[PyTango.DevVarStringArray, "<MacroLib name> [, <Macro name>]"],
            [PyTango.DevVarStringArray, "result is a sequence of 3 strings:\n"
                "<full path and file name>, <code>, <line number>" ]],
        'SetMacroCode':
            [[PyTango.DevVarStringArray, "<MacroLib name>, <code>\n" \
                "- if macro lib is a simple module name:\n" \
                "  - if it exists, it is overwritten otherwise a new python " \
                "file is created in the directory of the first element in "\
                "the MacroPath property" \
                "- if macro lib is the full path name:\n" \
                "  - if path is not in the MacroPath, an exception is thrown" \
                "  - if file exists it is overwritten otherwise a new file " \
                "is created"],
            [PyTango.DevVoid, "" ]],
        }

    #    Attribute definitions
    attr_list = {
        'DoorList':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 256]],
        'MacroList':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 4096]],
        'MacroLibList':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 1024]],
        'TypeList':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 256]],
        }


#------------------------------------------------------------------
#    MacroServerClass Constructor
#------------------------------------------------------------------
    def __init__(self, name):
        PyTango.DeviceClass.__init__(self, name)
        Logger.__init__(self, "%sClass" % name)
        
        self.set_type(name);

        
    def dyn_attr(self, dev_list):
        for dev in dev_list:
            dev.dyn_attr()

#==================================================================
#
#    MacroServer class main method
#
#==================================================================
def main(argv):
    l = get_main_log()
    l.info('Starting up...')
    
    pyu = PyTango.Util(sys.argv)
    
    pyu.add_TgClass(MacroServerClass, MacroServer, 'MacroServer')
    
    import Door
    pyu.add_TgClass(Door.DoorClass, Door.Door, 'Door')

    # make sure the polling is not active
    factory = taurus.Factory()
    factory.disablePolling()

    u = PyTango.Util.instance()
    u.set_serial_model(PyTango.SerialModel.BY_PROCESS)
    
    try:
        u.server_init()
    except PyTango.DevFailed, e1:
        l.critical("Critical error during server initialization: %s" % e1[0].desc)
        l.trace(str(e1))
        sys.exit(-1)
    except Exception, e:
        l.critical("Critical error during server initialization: %s" % str(e))
        sys.exit(-1)
    print 'Ready to accept request'

    try:
        u.server_run()
    except PyTango.DevFailed, e1:
        l.critical("Critical error during server run: %s" % e1[0].desc)
        l.trace(str(e1))
        sys.exit(-1)
    except Exception, e:
        l.critical("Critical error during server run: %s" % str(e))
        sys.exit(-1)


def run():
    try:
        main(sys.argv)
    except PyTango.DevFailed, e1:
        l = get_main_log()
        from taurus.core.util import str_DevFailed
        #l.error(str_DevFailed(e1))
        import traceback
        print traceback.print_exc()
        
    except Exception, e2:
        import traceback
        print traceback.print_exc()
        l = get_main_log()
        l.traceback()
    get_main_log().info('Server shutdown')
    print 'Exiting'
    print 'Exited'
    
    sys.exit()

if __name__ == '__main__':
    run()