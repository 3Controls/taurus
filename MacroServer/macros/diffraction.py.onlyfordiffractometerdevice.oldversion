"""
    Macro library containning diffractometer related macros for the macros 
    server Tango device server as part of the Sardana project.
    
"""

from macro import *

class _diffrac:
    """Internal class used as a base class for the diffractometer macros"""

    env = ('DiffracDevice',)
    
    def prepare(self):

        self.prepared = False
        
        dev_name = self.getEnv('DiffracDevice')        
        self.diffrac = self.getDevice(dev_name)
        
        prop = self.diffrac.get_property(['DiffractometerType'])        
        for v in prop['DiffractometerType']:       
            self.type = v

        self.prepared = True

class br(Macro, _diffrac):
    """The br macro is used to move the diffractometer to the reciprocal space 
    coordinates given by H, K and L."""

    param_def = [
       ['H', Type.Float, None, "H value"],
       ['K', Type.Float, None, "K value"],
       ['L', Type.Float, 1.0, "L value"]
    ]

    def prepare(self, H, K, L):
        _diffrac.prepare(self)
        
    def run(self, H, K, L):
        if not self.prepared:
            return
        
        values = []
        
        values.append(H)        
        values.append(K)        
        values.append(L)
        
        self.diffrac.setHKL(values)

class wh(Macro, _diffrac):
    """wh - where, principal axes and reciprocal space
        
    Prints the current reciprocal space coordinates (H K L) and the user 
    positions of the principal motors. Depending on the diffractometer geometry, 
    other parameters such as the angles of incidence and reflection (ALPHA and 
    BETA) and the incident wavelength (LAMBDA) may be displayed."""

    def prepare(self):
        _diffrac.prepare(self)
    
    def run(self):
        if not self.prepared:
            return
        
        if self.type == 'E6C':
            self.output("Mu = %7.5f  Omega = %7.5f  Chi  = %7.5f Phi = %7.5f Gamma %7.5f Delta %7.5f " % (self.diffrac.axisMu, self.diffrac.axisOmega, self.diffrac.axisChi, self.diffrac.axisPhi, self.diffrac.axisGamma, self.diffrac.axisDelta,))
            
        self.output("H = %7.5f  K = %7.5f L = %7.5f" % (self.diffrac.h, self.diffrac.k, self.diffrac.l))
            
        self.output("Wavelength = %7.5f" % (self.diffrac.waveLength))

class orn(Macro, _diffrac):
    """Set orientation reflection indicated by the index."""
    
    param_def = [
       ['i', Type.Integer, None, "reflection index (starting at 0)"],
       ['H', Type.Float,   None, "H value"],
       ['K', Type.Float,   None, "K value"],
       ['L', Type.Float,   None, "L value"],
    ]
    
    def prepare(self, i, H, K, L):
        _diffrac.prepare(self)
    
    def run(self, i, H, K, L):
        if not self.prepared:
            return        
# 0 -> relevance (obsolete). 1 -> for taking this reflection in affinement calculations  

        values = []  
        values.append(i)   
        values.append(H)  
        values.append(K)  
        values.append(L)  
        values.append(0)  
        values.append(1) 
          
        self.diffrac.SetReflection(values)
        
class or0(Macro, _diffrac):
    """Set primary orientation reflection."""
    
    param_def = [
       ['H', Type.Float, None, "H value"],
       ['K', Type.Float, None, "K value"],
       ['L', Type.Float, None, "L value"],
    ]
    
    def prepare(self, H, K, L):
        _diffrac.prepare(self)
    
    def run(self, H, K, L):
        if not self.prepared:
            return

        values = []  
        values.append(0)   
        values.append(H)  
        values.append(K)  
        values.append(L)  
        values.append(0)  
        values.append(1)
        
        self.diffrac.SetReflection(values)

class or1(Macro, _diffrac):
    """Set secondary orientation reflection."""
    
    param_def = [
       ['H', Type.Float, None, "H value"],
       ['K', Type.Float, None, "K value"],
       ['L', Type.Float, None, "L value"],
    ]
    
    def prepare(self, H, K, L):
        _diffrac.prepare(self)
    
    def run(self, H, K, L):
        if not self.prepared:
            return

        values = []  
        values.append(1)   
        values.append(H)  
        values.append(K)  
        values.append(L)  
        values.append(0)  
        values.append(1)
        
        self.diffrac.SetReflection(values)

class setorn(Macro, _diffrac):
    """Set orientation reflection indicated by the index."""
    
    param_def = [
       ['i', Type.Integer, None, "reflection index (starting at 0)"],
    ]
 
    
    def prepare(self):
        _diffrac.prepare(self)
    
    def run(self):
        if not self.prepared:
            return
        
        H = self.diffrac.h
        K = self.diffrac.k
        L = self.diffrac.l

        values = []  
        values.append(i)   
        values.append(H)  
        values.append(K)  
        values.append(L)  
        values.append(0)  
        values.append(1)
        
        self.diffrac.SetReflection(values)

class setor0(Macro, _diffrac):
    """Set primary orientation reflection. Alternative to or0"""
    
    def prepare(self):
        _diffrac.prepare(self)
    
    def run(self):
        if not self.prepared:
            return
        
        H = self.diffrac.h
        K = self.diffrac.k
        L = self.diffrac.l

        values = []  
        values.append(0)   
        values.append(H)  
        values.append(K)  
        values.append(L)  
        values.append(0)  
        values.append(1)
        
        self.diffrac.SetReflection(values)
        
class setor1(Macro, _diffrac):
    """Set secondary orientation reflection. Alternative to or1"""
    
    def prepare(self):
        _diffrac.prepare(self)
    
    def run(self):
        if not self.prepared:
            return

        values = []  
        values.append(1)   
        values.append(H)  
        values.append(K)  
        values.append(L)  
        values.append(0)  
        values.append(1)
        
        self.diffrac.SetReflection(values)
        
class setlat(Macro, _diffrac):
    """Set the crystal lattice parameters a, b, c, alpha, beta, gamma.
       for the currently active diffraction pseudo motor controller."""
    
    param_def = [
       ['a', Type.Float, None, "Lattice 'a' parameter"],
       ['b', Type.Float, None, "Lattice 'b' parameter"],
       ['c', Type.Float, None, "Lattice 'c' parameter"],
       ['alpha', Type.Float, None, "Lattice 'alpha' parameter"],
       ['beta',  Type.Float, None, "Lattice 'beta' parameter"],
       ['gamma', Type.Float, None, "Lattice 'gamma' parameter"]
    ]

    hints = { 'interactive' : 'True' }

    def prepare(self, a, b, c, alpha, beta, gamma):
        _diffrac.prepare(self)
    
    def run(self, a, b, c, alpha, beta, gamma):
        if not self.prepared:
            return

        values = []  
        values.append(a)   
        values.append(b)  
        values.append(c)  
        values.append(alpha)  
        values.append(beta)  
        values.append(gamma)
        
        self.diffrac.ConfigureCrystal(values)
        
class setmode(Macro, _diffrac):
    """Set operation mode."""
    
    param_def = [
       ['new_mode_1', Type.String, None, "Mode to be set"],
       ['new_mode_2', Type.String, " ", "Mode to be set"]
    ]    
   
    def prepare(self, new_mode_1, new_mode_2):
        _diffrac.prepare(self)
        
    def run(self, new_mode_1, new_mode_2):
        if not self.prepared:
            return   
        
        modes = self.diffrac.modeNames 
        
        mode = "%s %s" % (str(new_mode_1), str(new_mode_2))     
        
        set_mode = 0   
        
        for pd_mode in modes: 
            part_mode = pd_mode.split()
            if len(part_mode) == 1:
                if str(new_mode_1) == str(pd_mode): 
                    set_mode = pd_mode 
            else:
                if mode == pd_mode: 
                    set_mode = pd_mode
                    
        if set_mode == 0: 
            self.output("Wrong mode -> select one from the list:") 
            self.output(modes) 
            return
                    
        self.diffrac.write_attribute("mode",set_mode)


class H(Macro, _diffrac):
    """x component of the scattering vector."""

    result_def = [
        ['H',  Type.Float, None, 'x component of the scattering vector']
    ]

    def prepare(self):
        _diffrac.prepare(self)
        
    def run(self):
        if not self.prepared:
            return
        
        self.output(self.diffrac.h)

class K(Macro, _diffrac):
    """y component of the scattering vector."""

    result_def = [
        ['K',  Type.Float, None, 'y component of the scattering vector']
    ]

    def prepare(self):
        _diffrac.prepare(self)
        
    def run(self):
        if not self.prepared:
            return

        self.output(self.diffrac.k)

class L(Macro, _diffrac):
    """z component of the scattering vector."""

    result_def = [
        ['L',  Type.Float, None, 'z component of the scattering vector']
    ]

    def prepare(self):
        _diffrac.prepare(self)
        
    def run(self):
        if not self.prepared:
            return

        self.output(self.diffrac.l)
        
class LAMBDA(Macro, _diffrac):
    """x component of the scattering vector."""

    result_def = [
        ['LAMBDA',  Type.Float, None, 'Incident X-ray wavelength lambda.']
    ]

    def prepare(self):
        _diffrac.prepare(self)
        
    def run(self):
        if not self.prepared:
            return
        
        self.output(self.diffrac.waveLength)
    
class showUB(Macro, _diffrac):
    """Prints the current crystal UB matrix."""

    def prepare(self):
        _diffrac.prepare(self)
        
    def run(self):
        if not self.prepared:
            return
        
        self.output(self.diffrac.ub)
      
class pa(Macro, _diffrac):
    """Prints information about the active diffractometer."""
    
    suffix = ("st","nd","rd","th")
    
    def prepare(self):
        _diffrac.prepare(self)
        
    def run(self):
        if not self.prepared:
            return
        
        if self.type == 'E6C':
            str_type = "Eulerian 6C"        
        elif self.type == 'E4C':
            str_type = "Eulerian 4C"       
        elif self.type == 'E2C':
            str_type = "Eulerian 2C"
            
        self.output("%s Geometry, %s" % (str_type, self.diffrac.mode))
        self.output("Sector %s" % "[ToDo]")
        self.output("")

        
        nb_reflections = self.diffrac.GetReflectionSize()

        
        for i in range(0,nb_reflections):
            if i < len(self.suffix): sf = self.suffix[i]
            else: sf = self.suffix[3]
            reflection = self.diffrac.GetReflection(i)
            self.output("  %d%s Reflection (index %d): " % (i+1,sf,i))
            j = 0
            part = []
            for par in reflection:
                part.append(par)
                j = j + 1
            self.output("H %7.5f K %7.5f  L %7.5f  " % (part[0], part[1], part[2]))
            self.output("Angles ")
            for k in range(5, len(part)):
                self.output(part[k])
            self.output("")
        
        self.output("  Lattice Constants (lengths / angles):")
        self.output("%24s = %s %s %s / %s %s %s" % ("real space", self.diffrac.a, 
                                                    self.diffrac.b, self.diffrac.c, self.diffrac.alpha, 
                                                    self.diffrac.beta, self.diffrac.gamma))
        
        self.output("  Reciprocal Space (lengths / angles):")
        self.output("%24s = %7.5f %7.5f %7.5f / %s %s %s" % ("real space", self.diffrac.aStar, 
                                                    self.diffrac.bStar, self.diffrac.cStar, self.diffrac.alphaStar, 
                                                    self.diffrac.betaStar, self.diffrac.gammaStar))
        
        self.output("")
        self.output("  Azimuthal Reference:")
        self.output("%24s = %s" %("[ToDo]","[ToDo]"))
        self.output("")
        self.output("%24s = %s" %("Lambda",self.diffrac.waveLength))
        self.output("")
        self.output(" Cut Points:")
        self.output("    [ToDo]")
        
class ca(Macro, _diffrac):
    """Calculate motor positions for given H K L according to the current
    operation mode."""
    
    param_def = [
       ['H', Type.Float, None, "H value for the azimutal vector"],
       ['K', Type.Float, None, "K value for the azimutal vector"],
       ['L', Type.Float, None, "L value for the azimutal vector"],
    ]    
    
    def prepare(self, H, K , L):
        _diffrac.prepare(self)    
    
    def run(self, H, K, L):
        if not self.prepared:
            return
                
        saveH = self.diffrac.H               
        saveK = self.diffrac.K               
        saveL = self.diffrac.L

        simulation = self.diffrac.simulated

        change_simulation = 0

        if simulation == 0:             
            change_simulation = 1           
            self.diffrac.write_attribute("simulated",1)
        
        values = []
        
        values.append(H)        
        values.append(K)        
        values.append(L)
       
        self.diffrac.setHKL(values)                
                
        if self.type == 'E6C':
            self.output("Mu = %7.5f  Omega = %7.5f  Chi  = %7.5f Phi = %7.5f Gamma %7.5f Delta %7.5f " % (self.diffrac.axisMu, self.diffrac.axisOmega, self.diffrac.axisChi, self.diffrac.axisPhi, self.diffrac.axisGamma, self.diffrac.axisDelta,))
            self.output("Alpha = %s  Beta = %s  Azimuth = %s" % ("[ToDo]","[ToDo]","[ToDo]",))
            
        self.output("Omega = %s  Lambda = %7.5f" %("[TODO]",self.diffrac.waveLength))
        
        save_values = []
        
        save_values.append(saveH)        
        save_values.append(saveK)        
        save_values.append(saveL)
        
        self.diffrac.setHKL(save_values)
        
        if change_simulation == 1:            
            self.diffrac.write_attribute("simulated",0)
        
class cal(Macro, _diffrac):
    """Calculate motor positions for given H K L according to the current
    operation mode. Leave the motors in the calculated positions."""
    
    param_def = [
       ['H', Type.Float, None, "H value for the azimutal vector"],
       ['K', Type.Float, None, "K value for the azimutal vector"],
       ['L', Type.Float, None, "L value for the azimutal vector"],
    ]    
    
    def prepare(self, H, K , L):
        _diffrac.prepare(self)    
    
    def run(self, H, K, L):
        if not self.prepared:
            return

        simulation = self.diffrac.simulated

        change_simulation = 0

        if simulation == 1:             
            change_simulation = 1           
            self.diffrac.write_attribute("simulated",0)
        
        values = []
        
        values.append(H)        
        values.append(K)        
        values.append(L)
        
        self.diffrac.setHKL(values)
        
        if self.type == 'E6C':
            self.output("Mu = %7.5f  Omega = %7.5f  Chi  = %7.5f Phi = %7.5f Gamma %7.5f Delta %7.5f " % (self.diffrac.axisMu, self.diffrac.axisOmega, self.diffrac.axisChi, self.diffrac.axisPhi, self.diffrac.axisGamma, self.diffrac.axisDelta,))
            self.output("Alpha = %s  Beta = %s  Azimuth = %s" % ("[ToDo]","[ToDo]","[ToDo]",))
            
        self.output("Omega = %s  Lambda = %7.5f" %("[TODO]",self.diffrac.waveLength))
        
        if change_simulation == 1:            
            self.diffrac.write_attribute("simulated",1)

        
class ci(Macro, _diffrac):
    """Display calculated H K L for input angles."""
    
    param_def = [
       ['mu', Type.Float, None, "mu"],
       ['omega', Type.Float, None, "omega"],
       ['chi', Type.Float, -1, "chi"],
       ['phi', Type.Float, -1, "phi"],
       ['gamma', Type.Float, -1, "gamma"],
       ['delta', Type.Float, -1, "delta"]
    ]    
    
    def prepare(self, mu, omega, chi, phi, gamma, delta):
        _diffrac.prepare(self)    
    
    def run(self, mu, omega, chi, phi, gamma, delta):
        if not self.prepared:
            return
                
        if self.type == 'E6C':                
            savemu = self.diffrac.axisMu               
            saveomega = self.diffrac.axisOmega               
            savechi = self.diffrac.axisChi                
            savephi = self.diffrac.axisPhi               
            savegamma = self.diffrac.axisGamma               
            savedelta = self.diffrac.axisDelta

        simulation = self.diffrac.simulated

        change_simulation = 0

        if simulation == 0:             
            change_simulation = 1           
            self.diffrac.write_attribute("simulated",1)
                
        if self.type == 'E6C':                 
            self.diffrac.write_attribute("axisMu", mu)                 
            self.diffrac.write_attribute("axisOmega", omega)                 
            self.diffrac.write_attribute("axisChi", chi)                 
            self.diffrac.write_attribute("axisPhi", phi)                 
            self.diffrac.write_attribute("axisGamma", gamma)                 
            self.diffrac.write_attribute("axisDelta", delta)
            
        self.output("H = %7.5f  K = %7.5f  L  = %7.5f " % (self.diffrac.h, self.diffrac.k, self.diffrac.l,))
                
        if self.type == 'E6C':                 
            self.diffrac.write_attribute("axisMu", savemu)                 
            self.diffrac.write_attribute("axisOmega", saveomega)           
            self.diffrac.write_attribute("axisChi", savechi)                 
            self.diffrac.write_attribute("axisPhi", savephi)                 
            self.diffrac.write_attribute("axisGamma", savegamma)          
            self.diffrac.write_attribute("axisDelta", savedelta)

        if change_simulation == 1:            
            self.diffrac.write_attribute("simulated",0)
        
            
class calcA(Macro, _diffrac):
    """Calculate motor positions for current H K L."""
    
    def prepare(self):
        _diffrac.prepare(self)    
    
    def run(self):
        if not self.prepared:
            return
        
        if self.type == 'E6C':
            self.output("Mu = %7.5f  Omega = %7.5f  Chi  = %7.5f Phi = %7.5f Gamma %7.5f Delta %7.5f " % (self.diffrac.axisMu, self.diffrac.axisOmega, self.diffrac.axisChi, self.diffrac.axisPhi, self.diffrac.axisGamma, self.diffrac.axisDelta,))
        
class calcHKL(Macro, _diffrac):
    """Calculate H K L for current motor positions"""

    def prepare(self):
        _diffrac.prepare(self)
            
    def run(self):
        if not self.prepared:
            return
        
        self.output("H = %7.5f  K = %7.5f  L  = %7.5f " % (self.diffrac.h, self.diffrac.k, self.diffrac.l,))
