//+=============================================================================
//
// file :         OneDExpChannel.cpp
//
// description :  C++ source for the OneDExpChannel and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                OneDExpChannel are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author:  $
//
// $Revision:  $
//
// $Log:  $
//
// copyleft :     European Synchrotron Radiation Facility
//                BP 220, Grenoble 38043
//                FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondance
//	between commands and method's name.
//
//  Command's name|  Method's name
//	----------------------------------------
//  State   |  dev_state()
//  Status  |  dev_status()
//  Start   |  start()
//  Abort   |  abort()
//
//===================================================================


#include "CtrlFiCa.h"
#include <tango.h>
#include "OneDExpChannel.h"
#include "OneDExpChannelClass.h"
#include "Pool.h"
#include "PoolUtil.h"
#include "OneDExpChannelUtil.h"
#include "OneDThread.h"
#include "MeasurementGroup.h"

#include <pool/OneDCtrl.h>

#include <numeric>


namespace OneDExpChannel_ns
{

//+----------------------------------------------------------------------------
//
// method : 		OneDExpChannel::OneDExpChannel(string &s)
// 
// description : 	constructor for simulated OneDExpChannel
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
OneDExpChannel::OneDExpChannel(Tango::DeviceClass *cl,string &s)
:Pool_ns::PoolIndBaseDev(cl,s.c_str())
//:Tango::Device_4Impl(cl,s.c_str())
{ 
    init_cmd = false;
    init_device();
}

OneDExpChannel::OneDExpChannel(Tango::DeviceClass *cl,const char *s)
:Pool_ns::PoolIndBaseDev(cl,s)
//:Tango::Device_4Impl(cl,s)
{ 
    init_cmd = false;
    init_device();
}

OneDExpChannel::OneDExpChannel(Tango::DeviceClass *cl,const char *s,const char *d)
:Pool_ns::PoolIndBaseDev(cl,s,d)
//:Tango::Device_4Impl(cl,s,d)
{  
    init_cmd = false;
    init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		OneDExpChannel::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void OneDExpChannel::delete_device()
{       
    INFO_STREAM << "OneDExpChannel::delete_device() " << device_name << endl;
    //	Delete device's allocated object
    
    if (attr_Data_read) {
        delete[] attr_Data_read;
        attr_Data_read = 0;
    }
        
    if (attr_Value_read) {
        delete[] attr_Value_read;
        attr_Value_read = 0;
    }
    


//
// To know that we are executing this code due to a pool shutdown and not due to a
// "Init" command, we are using the polling thread ptr which is cleared in the DS
// shutdown sequence before the device destruction
//
    bool sd = false;


    Tango::Util *tg = Tango::Util::instance();
    if (tg->get_polling_thread_object() != NULL)
    {
        if (get_state() == Tango::MOVING)
        {
            TangoSys_OMemStream o;
            o << "Init command on 1D channel device is not allowed while a 1D channel is counting" << ends;

            Tango::Except::throw_exception((const char *)"OneDExp_InitNotAllowed",o.str(),
                    (const char *)"OneDExpChannel::delete_device");
        }
    }
    else
    {
        sd = true;
    }

    if (save_atts != NULL)
        delete save_atts;

//
// If we are not in a shutdown sequence:
// Lock the ghost group in order the polling thread not to
// start requesting for motor state while we are deleting it and
// inform ghost group that there is one channel less
//
// If we are called due to a Init command on the DServer admin,
// the measurement_group class is already deleted and the ghost group
// as well
//

    if (sd == false)
    {
        bool measurementgroup_class_deleted = false;
        MeasurementGroup_ns::MeasurementGroup *ghost_ptr;
        
        try
        {
            ghost_ptr = pool_dev->get_ghost_measurement_group_ptr();
        }
        catch (Tango::DevFailed &e)
        {
            measurementgroup_class_deleted = true;
        }
        
        if (measurementgroup_class_deleted == false)
        {
            Tango::AutoTangoMonitor atm(ghost_ptr);
            ghost_ptr->remove_channel_from_ghost_group(get_id());
        }
    }
                
//
// Delete the device from its controller and from the pool
//
    the_shared_data.read_values.clear();
    the_shared_data.acq_dates.clear();
    
    // If in shutdown mode, protect against exceptions
    if (sd)
    {
        try
        {
            delete_from_pool();
        }
        catch(Tango::DevFailed &df)
        {
            std::cout << "Error deleting '"<< get_name()
                      << "' from controller:" << std::endl;
            Tango::Except::print_exception(df);
        }
        catch(...)
        {
            std::cout << "Unknown error deleting '"<< get_name()
                      << "' from controller." << std::endl;
        }        
    }
    else
    {
        delete_from_pool();
    }
    delete_utils();

    PoolIndBaseDev::delete_device();
}

//+----------------------------------------------------------------------------
//
// method : 		OneDExpChannel::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void OneDExpChannel::init_device()
{
    INFO_STREAM << "OneDExpChannel::OneDExpChannel() create device " << device_name << endl;

    // Initialise variables to default values
    //--------------------------------------------	
    PoolIndBaseDev::init_device();
    
//
// Init some variables
//

    save_atts = NULL;
//	read_value  = 0.0;
//	cum_read_value = 0.0;
//	cum_nb = 0;
//	cum_err = 0;
    th = NULL;
    
//	if (init_cmd == false)
//	{
//	attr_CumulationType_write = Pool_ns::AVERAGE;
//		attr_CumulationTime_write = 0.0;
//	}
    
//	Tango::WAttribute &acq_att = dev_attr->get_w_attr_by_name("CumulationType");
//	acq_att.set_write_value((long)Pool_ns::AVERAGE);
        
    if(maxDataLength < 1) maxDataLength = 10000;

    attr_Data_read = new Tango::DevDouble[maxDataLength];
    ::memset(attr_Data_read, 0,  maxDataLength * sizeof(Tango::DevDouble));

    attr_Value_read = new Tango::DevDouble[maxDataLength];
    ::memset(attr_Value_read, 0,  maxDataLength * sizeof(Tango::DevDouble));

    attr_DataLength_write = maxDataLength;

    

//	the_shared_data.error_nb = 0;
//	the_shared_data.cont_error = continueOnError;
//	the_shared_data.stop_if_no_time = stopIfNoTime;
//	the_shared_data.i_am_dead = false;
    
//
// We will push change event on State and Cumulated Value attributes
//

    Tango::Attribute &state_att = dev_attr->get_attr_by_name("state");
    state_att.set_change_event(true,false);
    
//	Tango::Attribute &val_att = dev_attr->get_attr_by_name("CumulatedValue");
//	val_att.set_change_event(true);
        
//
// Build the PoolBaseUtils class depending on the
// controller type
//

    set_utils(new OneDExpChannelUtil(pool_dev));
    
//
// Inform Pool of our birth
//

    Pool_ns::OneDExpChannelPool *oned_pool_ptr = new Pool_ns::OneDExpChannelPool;
    init_pool_element(oned_pool_ptr);
    
    
    
    {
        Tango::AutoTangoMonitor atm(pool_dev);	
        pool_dev->add_element(oned_pool_ptr);
    }

//
// Inform controller of our birth
//

    a_new_child(oned_pool_ptr->get_ctrl_id());
    
//
// If we are called due to a init command, update our info in the
// ghost group
//
        
    if (init_cmd == true)
    {
        MeasurementGroup_ns::MeasurementGroup *ghost_ptr = pool_dev->get_ghost_measurement_group_ptr();
        {
            Tango::AutoTangoMonitor atm(ghost_ptr);
            ghost_ptr->add_oned_to_ghost_group(get_id());
        }
        init_cmd = false;
    }
    
}

Pool_ns::OneDExpChannelPool &OneDExpChannel::get_oned_element()
{
    return static_cast<Pool_ns::OneDExpChannelPool &>(get_pool_element());
}

//+----------------------------------------------------------------------------
//
// method : 		OneDExpChannel::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void OneDExpChannel::get_device_property()
{
    //	Initialize your default values here (if not done with  POGO).
    //------------------------------------------------------------------
    PoolIndBaseDev::get_device_property();
    
    //	Read device properties from database.(Automatic code generation)
    //------------------------------------------------------------------
    Tango::DbData	dev_prop;
    dev_prop.push_back(Tango::DbDatum("MaxDataLength"));

    //	Call database and extract values
    //--------------------------------------------
    if (Tango::Util::instance()->_UseDb==true)
        get_db_device()->get_property(dev_prop);
    Tango::DbDatum	def_prop, cl_prop;
    OneDExpChannelClass	*ds_class =
        (static_cast<OneDExpChannelClass *>(get_device_class()));
    int	i = -1;

    //	Try to initialize MaxDataLength from class property
    cl_prop = ds_class->get_class_property(dev_prop[++i].name);
    if (cl_prop.is_empty()==false)	cl_prop  >>  maxDataLength;
    //	Try to initialize MaxDataLength from default device value
    def_prop = ds_class->get_default_device_property(dev_prop[i].name);
    if (def_prop.is_empty()==false)	def_prop  >>  maxDataLength;
    //	And try to extract MaxDataLength value from database
    if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxDataLength;



    //	End of Automatic code generation
    //------------------------------------------------------------------

}

//+----------------------------------------------------------------------------
//
// method : 		OneDExpChannel::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void OneDExpChannel::always_executed_hook()
{
    
    Tango::DevState old_state = get_state();
/*	
    if (old_state != Tango::MOVING)
    {
        bool th_dead;	
        {
            omni_mutex_lock lo(the_mutex);
            th_dead = the_shared_data.i_am_dead;
        }

//
// If the thread is dead,reclaim its memory
//
    
        if ((th_dead == true) && (th != NULL))
        {
            void *ptr;		
            th->join(&ptr);
            th = NULL;
        }
        
        base_always_executed_hook(false,false);
        Tango::DevState local_state = get_state();
        if ((local_state != Tango::ON) && 
            (local_state != Tango::FAULT) &&
            (local_state != Tango::UNKNOWN))
        {
            set_state(Tango::FAULT);
            unknown_state = true;
        }
    }
*/   
    base_always_executed_hook(false);

    
    inform_ghost(old_state,get_state());


}
//+----------------------------------------------------------------------------
//
// method : 		OneDExpChannel::inform_ghost
// 
// description : 	inform ghost group of a change in the state
//
//-----------------------------------------------------------------------------

void OneDExpChannel::inform_ghost(Tango::DevState old_state,Tango::DevState new_state)
{

    if (old_state != Tango::MOVING)
    {
        if(old_state != new_state && 
           new_state != Tango::ON &&
           new_state != Tango::MOVING)
        {
            try
            {
                MeasurementGroup_ns::MeasurementGroup *ghost = pool_dev->get_ghost_measurement_group_ptr();
                long idx = ghost->get_ind_elt_idx_from_id(get_id());
                Tango::AutoTangoMonitor synch(ghost);
                ghost->update_state_from_ctrls(idx,new_state);
            }
            catch(Tango::DevFailed &df)
            { /* if ghost is not yet created then no choice but to ignore this */ }
        }
    }
}
//+----------------------------------------------------------------------------
//
// method : 		OneDExpChannel::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void OneDExpChannel::read_attr_hardware(vector<long> &attr_list)
{
    DEBUG_STREAM << "OneDExpChannel::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
    //	Add your own code here
}
//+----------------------------------------------------------------------------
//
// method : 		OneDExpChannel::read_Value
// 
// description : 	Extract real attribute values for Value acquisition result.
//
//-----------------------------------------------------------------------------
void OneDExpChannel::read_Value(Tango::Attribute &attr)
{
    DEBUG_STREAM << "OneDExpChannel::read_Value(Tango::Attribute &attr) entering... "<< endl;

    Pool_ns::OneDExpChannelPool &oned_element = get_oned_element();

    if (!oned_element.get_simulation_mode())
    {
        
//
// If we are not acquiring data, returns the value coming from the controller
//
        
        Pool_ns::AutoPoolLock lo(fica_ptr->get_mon());
        string par_name("DataLength");
        Controller::CtrlData tmp_val;
        try
        {
            OneDController *typed_ctrl = static_cast<OneDController *>(oned_element.get_controller());
            
            typed_ctrl->PreReadAll();
            typed_ctrl->PreReadOne(get_axis());
            typed_ctrl->ReadAll();
         
            attr_Value_read = (Tango::DevDouble*)typed_ctrl->ReadOne(get_axis());

            tmp_val = typed_ctrl->GetPar(get_axis(),par_name);

        }
        SAFE_CATCH(fica_ptr->get_name(),"read_Value");

        if (tmp_val.int32_data == 0x7fffffffL)
        {
            Tango::Except::throw_exception((const char *)"OneDExpChannel_BadController",
                                           (const char *)"The OneDExpChannel controller class has not re-defined method to get OneDExpChannel parameters",
                                           (const char *)"OneDExpChannel::read_Value");
        }
        attr_DataLength_write = tmp_val.int32_data;

        if(attr_Value_read == NULL)
        {
            Tango::Except::throw_exception((const char *)"OneDExpChannel_BadController",
                                           (const char *)"The One D Exp Channel controller class has not re-defined method to read value (ReadOne(...))",
                                           (const char *)"OneDExpChannel::read_Value");
        }

    }
    else
    {
        *attr_Value_read = 0.0;
    }

    attr.set_value(attr_Value_read, attr_DataLength_write);
}

//+------------------------------------------------------------------
/**
 *	method:	OneDExpChannel::dev_status
 *
 *	description:	method to execute "Status"
 *	This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *
 * @return	Status description
 *
 */
//+------------------------------------------------------------------
Tango::ConstDevString OneDExpChannel::dev_status()
{
    Tango::ConstDevString	argout = DeviceImpl::dev_status();
    DEBUG_STREAM << "OneDExpChannel::dev_status(): entering... !" << endl;

    //	Add your own code to control device here

    base_dev_status(argout);


    argout = tmp_status.c_str();
    return argout;
}



//+----------------------------------------------------------------------------
//
// method : 		OneDExpChannel::read_DataLength
// 
// description : 	Extract real attribute values for DataLength acquisition result.
//
//-----------------------------------------------------------------------------
void OneDExpChannel::read_DataLength(Tango::Attribute &attr)
{
    DEBUG_STREAM << "OneDExpChannel::read_DataLength(Tango::Attribute &attr) entering... "<< endl;
    
    Pool_ns::OneDExpChannelPool &oned_element = get_oned_element();
    
    string par_name("DataLength");
    if (!oned_element.get_simulation_mode())
    {
            
        Pool_ns::AutoPoolLock lo(fica_ptr->get_mon());
        Controller::CtrlData tmp_val;
        try
        {
            OneDController *typed_ctrl = static_cast<OneDController *>(oned_element.get_controller());
            tmp_val = typed_ctrl->GetPar(get_axis(),par_name);
        }
        SAFE_CATCH(fica_ptr->get_name(),"read_DataLength");
        
        if (tmp_val.int32_data == INT_MAX)
        {
            Tango::Except::throw_exception((const char *)"OneDExpChannel_BadController",
                      (const char *)"The OneDExpChannel controller class has not re-defined method to get OneDExpChannel parameters",
                                           (const char *)"OneDExpChannel::read_DataLength");
        }
        attr_DataLength_write = tmp_val.int32_data;
    }

    attr.set_value( &attr_DataLength_write );

}

//+----------------------------------------------------------------------------
//
// method : 		OneDExpChannel::write_DataLength
// 
// description : 	Write DataLength attribute values to hardware.
//
//-----------------------------------------------------------------------------
void OneDExpChannel::write_DataLength(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "OneDExpChannel::write_DataLength(Tango::WAttribute &attr) entering... "<< endl;

    Pool_ns::OneDExpChannelPool &oned_element = get_oned_element();
    
    attr.get_write_value( attr_DataLength_write);
    if (attr_DataLength_write <= 0)
    {
        Tango::Except::throw_exception((const char *)"OneDExpChannel_BadArgument",
                                       (const char *)"DataLength cannot be negative or null",
                                       (const char *)"OneDExpChannel::write_DataLength");
    }

    string par_name("DataLength");
    Controller::CtrlData tmp_data;
    tmp_data.data_type = Controller::INT32;
    tmp_data.int32_data = attr_DataLength_write;
    if (!oned_element.get_simulation_mode())
    {
        
        Pool_ns::AutoPoolLock lo(fica_ptr->get_mon());	
        
        try
        {
            OneDController *typed_ctrl = static_cast<OneDController *>(oned_element.get_controller());
            typed_ctrl->SetPar(get_axis(),par_name,tmp_data);              
        }
        SAFE_CATCH(fica_ptr->get_name(),"write_DataLength");
    }  

}

//+----------------------------------------------------------------------------
//
// method : 		OneDExpChannel::read_Data
// 
// description : 	Extract real attribute values for Data acquisition result.
//
//-----------------------------------------------------------------------------
void OneDExpChannel::read_Data(Tango::Attribute &attr)
{
    DEBUG_STREAM << "OneDExpChannel::read_Data(Tango::Attribute &attr) entering... "<< endl;
    
    Pool_ns::OneDExpChannelPool &oned_element = get_oned_element();
    
    if (!oned_element.get_simulation_mode())
    {	
        
//
// If we are not acquiring data, returns the value coming from the controller
//
        
        Pool_ns::AutoPoolLock lo(fica_ptr->get_mon());
        string par_name("DataLength");
        Controller::CtrlData tmp_val;
        try
        {
            OneDController *typed_ctrl = static_cast<OneDController *>(oned_element.get_controller());
            
            typed_ctrl->PreReadAll();
            typed_ctrl->PreReadOne(get_axis());
            typed_ctrl->ReadAll();
         
            attr_Data_read = (Tango::DevDouble*)typed_ctrl->ReadOne(get_axis());

            tmp_val = typed_ctrl->GetPar(get_axis(),par_name);

        }
        SAFE_CATCH(fica_ptr->get_name(),"read_Data");
        
        if (tmp_val.int32_data == 0x7fffffffL)
        {
            Tango::Except::throw_exception((const char *)"OneDExpChannel_BadController",
                                           (const char *)"The OneDExpChannel controller class has not re-defined method to get OneDExpChannel parameters",
                                           (const char *)"OneDExpChannel::read_Data");
        }
        attr_DataLength_write = tmp_val.int32_data;

        if(attr_Data_read == NULL)
        {
            Tango::Except::throw_exception((const char *)"OneDExpChannel_BadController",
                                           (const char *)"The One D Exp Channel controller class has not re-defined method to read value (ReadOne(...))",
                                           (const char *)"OneDExpChannel::read_Data");
        }

    }
    else
    {
        *attr_Data_read = 0.0;
    }

    attr.set_value(attr_Data_read, attr_DataLength_write);
}


//+------------------------------------------------------------------
/**
 *	method:	OneDExpChannel::start
 *
 *	description:	method to execute "Start"
 *	Start acquiring data
 *
 *
 */
//+------------------------------------------------------------------
void OneDExpChannel::start()
{
    DEBUG_STREAM << "OneDExpChannel::start(): entering... !" << endl;

    //	Add your own code to control device here
    
    Pool_ns::OneDExpChannelPool &oned_element = get_oned_element();

    if (!oned_element.get_simulation_mode())
    {	

        Pool_ns::AutoPoolLock lo(fica_ptr->get_mon());
        
        try
        {
            OneDController *typed_ctrl = static_cast<OneDController *>(oned_element.get_controller());

            typed_ctrl->StartOne(get_axis());
        }
        SAFE_CATCH(fica_ptr->get_name(),"start");
        set_state(Tango::MOVING);
        Tango::MultiAttribute *dev_attrs = get_device_attr();
        Tango::Attribute &state_att = dev_attrs->get_attr_by_name("State");
        state_att.fire_change_event();
        
    }
    else
    {
        Tango::Except::throw_exception((const char *)"OneDExpChannel_SimuMode",
                                       (const char *)"Command not allowed when in simulation mode",
                                       (const char *)"OneDExpChannel::start");
    }
    
    
    
}

//+------------------------------------------------------------------
/**
 *	method:	OneDExpChannel::abort
 *
 *	description:	method to execute "Abort"
 *	Stop acquiring data
 *
 *
 */
//+------------------------------------------------------------------
void OneDExpChannel::abort()
{
    DEBUG_STREAM << "OneDExpChannel::abort(): entering... !" << endl;

    //	Add your own code to control device here
    base_abort(true);
}


//+------------------------------------------------------------------
/**
 *	method:	OneDExpChannel::base_abort
 *
 *	description:	method to execute "Abort"
 *	Stop acquiring data
 *
 *
 */
//+------------------------------------------------------------------
void OneDExpChannel::base_abort(bool send_evt)
{
    Pool_ns::OneDExpChannelPool &oned_element = get_oned_element();
    
    if (!oned_element.get_simulation_mode())
    {	
        
        Pool_ns::AutoPoolLock lo(fica_ptr->get_mon());
        
        try
        {
            OneDController *typed_ctrl = static_cast<OneDController *>(oned_element.get_controller());

            typed_ctrl->AbortOne(get_axis());
        }
        SAFE_CATCH(fica_ptr->get_name(),"abort");
        
        Tango::MultiAttribute *dev_attrs = get_device_attr();
        set_state(Tango::ON);
        Tango::Attribute &state_att = dev_attrs->get_attr_by_name("State");
        state_att.fire_change_event();
        
    }
    else
    {
        Tango::Except::throw_exception((const char *)"OneDExpChannel_SimuMode",
                                       (const char *)"Command not allowed when in simulation mode",
                                       (const char *)"OneDExpChannel::abort");
    }

    
    if(send_evt)
    {
        set_state(Tango::ON);
        Tango::MultiAttribute *dev_attrs = get_device_attr();
        Tango::Attribute &state_att = dev_attrs->get_attr_by_name("State");
        state_att.fire_change_event();

    }
}

OneDExpChannel::Simu_data::Simu_data(OneDExpChannel *chan):channel(chan)
{
    Tango::AutoTangoMonitor atm(channel);
    
//	simu_time = channel->attr_CumulationTime_write;
//	simu_type = channel->attr_CumulationType_write;
}

OneDExpChannel::Simu_data::~Simu_data()
{
/*	
    Tango::AutoTangoMonitor atm(channel);
    
    Tango::MultiAttribute *ma_ptr = channel->get_device_attr();
    if (channel->attr_CumulationTime_write != simu_time)
    {
        channel->attr_CumulationTime_write = simu_time;
        Tango::WAttribute &att = ma_ptr->get_w_attr_by_name("CumulationTime");
        att.set_write_value(simu_time);
    }
    
    if (channel->attr_CumulationType_write != simu_type)
    {
        channel->attr_CumulationType_write = simu_type;
        Tango::WAttribute &att = ma_ptr->get_w_attr_by_name("CumulationType");
        att.set_write_value(simu_type);
    }
*/
}

}	//	namespace
