//+=============================================================================
//
// file :         IORegister.cpp
//
// description :  C++ source for the IORegister and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                IORegister are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author:  $
//
// $Revision:  $
//
// $Log:  $
//
// copyleft :     European Synchrotron Radiation Facility
//                BP 220, Grenoble 38043
//                FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondance
//	between commands and method's name.
//
//  Command's name|  Method's name
//	----------------------------------------
//  State   |  dev_state()
//  Status  |  dev_status()
//
//===================================================================

#include "Pool.h"
#include "Utils.h"
#include "PoolUtil.h"
#include "IORegister.h"
#include "IORegisterClass.h"
#include "IORegisterUtil.h"

#include <tango.h>
#include <pool/IORegisterCtrl.h>


namespace IORegister_ns
{

//+----------------------------------------------------------------------------
//
// method : 		IORegister::IORegister(string &s)
// 
// description : 	constructor for simulated IORegister
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
IORegister::IORegister(Tango::DeviceClass *cl,string &s)
//:Tango::Device_4Impl(cl,s.c_str())
:Pool_ns::PoolIndBaseDev(cl,s.c_str())
{
    init_cmd = false;
    init_device();
}

IORegister::IORegister(Tango::DeviceClass *cl,const char *s)
//:Tango::Device_4Impl(cl,s)
:Pool_ns::PoolIndBaseDev(cl,s)
{
    init_cmd = false;
    init_device();
}

IORegister::IORegister(Tango::DeviceClass *cl,const char *s,const char *d)
//:Tango::Device_4Impl(cl,s,d)
:Pool_ns::PoolIndBaseDev(cl,s,d)
{
    init_cmd = false;
    init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		IORegister::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void IORegister::delete_device()
{
    //	Delete device's allocated object//

// To know that we are executing this code due to a pool shutdown and not due to a
// "Init" command, we are using the polling thread ptr which is cleared in the DS
// shutdown sequence before the device destruction
//
    bool sd = false;

    Tango::Util *tg = Tango::Util::instance();
    if (tg->get_polling_thread_object() != NULL)
    {
        if (get_state() == Tango::MOVING)
        {
            TangoSys_OMemStream o;
            o << "Init command on IORegister device is not allowed while a IORegister is reading/writing" << ends;

            Tango::Except::throw_exception((const char *)"IORegister_InitNotAllowed",o.str(),
                    (const char *)"IORegister::delete_device");
        }
    }
    else
    {
        sd = true;
    }

//
// If we are not in a shutdown sequence:
// Lock the ghost group in order the polling thread not to
// start requesting for motor state while we are deleting it and
// inform ghost group that there is one channel less
//
// If we are called due to a Init command on the DServer admin,
// the measurement_group class is already deleted and the ghost group
// as well
//

    if (sd == false)
    {
        // TODO: ghost group
    }
    
//
// Delete the device from its controller and from the pool
//
    // If in shutdown mode, protect against exceptions
    if (sd)
    {
        try
        {
            delete_from_pool();
        }
        catch(Tango::DevFailed &df)
        {
            std::cout << "Error deleting '"<< get_name()
                      << "' from controller:" << std::endl;
            Tango::Except::print_exception(df);
        }
        catch(...)
        {
            std::cout << "Unknown error deleting '"<< get_name()
                      << "' from controller." << std::endl;
        }        
    }
    else
    {
        delete_from_pool();
    }
    delete_utils();
    
    PoolIndBaseDev::delete_device();
}

//+----------------------------------------------------------------------------
//
// method : 		IORegister::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void IORegister::init_device()
{
    INFO_STREAM << "IORegister::IORegister() create device " << device_name << endl;

    // Initialise variables to default values
    //--------------------------------------------
    PoolIndBaseDev::init_device();
    
//
// Init some variables
//

//
// We will push change event on State and Value attributes
//

    Tango::Attribute &state_att = dev_attr->get_attr_by_name("state");
    state_att.set_change_event(true,false);

//
// Build the PoolBaseUtils class depending on the
// controller type
//

    set_utils(new IORegisterUtil(pool_dev));
    
//
// Inform Pool of our birth
//

    Pool_ns::IORegisterPool *ior_pool_dev = new Pool_ns::IORegisterPool;
    init_pool_element(ior_pool_dev);
    
    {
        Tango::AutoTangoMonitor atm(pool_dev);
        pool_dev->add_element(ior_pool_dev);
    }

//
// Inform controller of our birth
//

    a_new_child(ior_pool_dev->get_ctrl_id());
    
//
// If we are called due to a init command, update our info in the
// ghost group
//
        
    if (init_cmd == true)
    {
        //TODO: ghost group
        init_cmd = false;
    }
}

//+----------------------------------------------------------------------------
//
// method : 		IORegister::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void IORegister::get_device_property()
{
    //	Initialize your default values here (if not done with  POGO).
    //------------------------------------------------------------------
    PoolIndBaseDev::get_device_property();
    
    //	Read device properties from database.(Automatic code generation)
    //------------------------------------------------------------------

    //	End of Automatic code generation
    //------------------------------------------------------------------

}
//+----------------------------------------------------------------------------
//
// method : 		IORegister::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void IORegister::always_executed_hook()
{
    INFO_STREAM << "IORegister::always_executed_hook entering... "<< endl;
    
    Pool_ns::IORegisterPool &ioregister_element = get_ioregister_element();
    
    bool propagate = true;
    
    if (!ioregister_element.get_simulation_mode())
    {
        Tango::DevState old_state = get_state();
        
        if (is_fica_built())
        {
            unknown_state = false;
            Pool_ns::PoolLock &pl = fica_ptr->get_mon();
            Pool_ns::AutoPoolLock lo(pl);
            if (!this->ctrl_code_online)
            {
                set_state(Tango::FAULT);
            }
            else
            {
                if (ioregister_element.is_add_device_done())
                {
                    Controller::CtrlState mi;
                    try
                    {
                        read_state_from_ctrl(mi,false);
                        set_state((Tango::DevState)mi.state);
                        ctrl_str = mi.status;
                    }
                    catch(Tango::DevFailed &e)
                    {
                        set_state(Tango::UNKNOWN);
                        ctrl_str = "Error reported from controller when requesting for object state\n\t";
                        ctrl_str += e.errors[0].desc.in();
                    }
                }
                else
                    set_state(Tango::FAULT);
            }
        }
        else
        {
            set_state(Tango::FAULT);
        }
        
//
// If necessary notify the ghost group of changes in this element.
// The ghost group will itself notify any internal listeners. 
//
        if(propagate == true)
        {
            inform_ghost(old_state,get_state());
        }
    }
}

Pool_ns::IORegisterPool &IORegister::get_ioregister_element()
{
    return static_cast<Pool_ns::IORegisterPool &>(get_pool_element());
}

//+----------------------------------------------------------------------------
//
// method : 		IORegister::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void IORegister::read_attr_hardware(vector<long> &attr_list)
{
    DEBUG_STREAM << "IORegister::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
    //	Add your own code here
}

//+----------------------------------------------------------------------------
//
// method : 		IORegister::read_Value
// 
// description : 	Extract real attribute values for Value acquisition result.
//
//-----------------------------------------------------------------------------
void IORegister::read_Value(Tango::Attribute &attr)
{
    DEBUG_STREAM << "IORegister::read_Value(Tango::Attribute &attr) entering... "<< endl;
    
    Pool_ns::IORegisterPool &ioregister_element = get_ioregister_element();
   
    if (!ioregister_element.get_simulation_mode())
    {
        
//
// If we are not acquiring data, returns the value coming from the controller
//
        
        Pool_ns::AutoPoolLock lo(fica_ptr->get_mon());
        
        try
        {
            IORegisterController *typed_ctrl = static_cast<IORegisterController *>(ioregister_element.get_controller());
            
            //		typed_ctrl->PreReadAll();
            //	typed_ctrl->PreReadOne(get_axis());
            //	typed_ctrl->ReadAll();
            attr_Value_write = typed_ctrl->ReadOne(get_axis());
        }
        SAFE_CATCH(fica_ptr->get_name(),"read_Value");
        
        if (isnan(attr_Value_write) != 0)
        {
            Tango::Except::throw_exception((const char *)"IORegister_BadController",
                  (const char *)"The IORegister controller class has not re-defined method to read value (readOne(...))",
                  (const char *)"IORegister::read_Value");
        }
    }
    else
    {
        attr_Value_write = 0;
    }
    
    attr.set_value(&attr_Value_write);

}

//+----------------------------------------------------------------------------
//
// method : 		IORegister::write_Value
// 
// description : 	Write Value attribute values to hardware.
//
//-----------------------------------------------------------------------------
void IORegister::write_Value(Tango::WAttribute &attr)
{
    DEBUG_STREAM << "IORegister::write_Value(Tango::WAttribute &attr) entering... "<< endl; 
    
    Pool_ns::IORegisterPool &ioregister_element = get_ioregister_element();
    
    attr.get_write_value(attr_Value_write);
    
    if (!ioregister_element.get_simulation_mode())
    {
        Pool_ns::AutoPoolLock lo(fica_ptr->get_mon());
        
        try
        {
            IORegisterController *typed_ctrl = static_cast<IORegisterController *>(ioregister_element.get_controller());
            
            //	typed_ctrl->PreWriteAll();
            //	typed_ctrl->PreWriteOne(get_axis());
            //		typed_ctrl->WriteAll();
            typed_ctrl->WriteOne(get_axis(), attr_Value_write);
        }
        SAFE_CATCH(fica_ptr->get_name(),"write_Value");

    } 

}

//+------------------------------------------------------------------
/**
 *	@fn	IORegister::dev_status
 *
 *	description:	method to execute "Status"
 *	This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *
 * @return	Status description
 *
 */
//+------------------------------------------------------------------
Tango::ConstDevString IORegister::dev_status()
{
    Tango::ConstDevString	argout = DeviceImpl::dev_status();
    DEBUG_STREAM << "CommunicationChannel::dev_status(): entering... !" << endl;

    //	Add your own code to control device here

    base_dev_status(argout);
    
    argout = tmp_status.c_str();
    return argout;
}

//+----------------------------------------------------------------------------
/**
 * Inform ghost group of a change in the state
 * 
 * @param old_state the old state
 * @param new_state the new state
 */
//+----------------------------------------------------------------------------
void IORegister::inform_ghost(Tango::DevState old_state,Tango::DevState new_state)
{
    //TODO	
}


}	//	namespace
